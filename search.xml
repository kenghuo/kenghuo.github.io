<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js 总结]]></title>
    <url>%2F2019%2F05%2F15%2Fjs%2F</url>
    <content type="text"><![CDATA[很多内容都是零零散散的，把之前学的用的JavaScript相关内容整理下。对自己之前的学习做个系统的整理 js数据类型1.基本类型undefined、null、number、string、boolean 以及 es6 提出的 symbol 总共 6 种基本数据类型 2.引用类型Object、Array 以及 Set、Map 等]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git_command]]></title>
    <url>%2F2019%2F05%2F14%2Fgit-command%2F</url>
    <content type="text"><![CDATA[git 命令集合 $ git clone url dirname #克隆远程版本库 dirname可选 克隆代码到指定dirname目录$ git init dirname #初始化本地版本库 同上 $ git status #查看状态$ git diff #查看变更内容$ git add . #跟踪所有改动过的文件$ git add file #跟踪指定的文件 $ git mv oldnew #文件改名$ git rmfile #删除文件$ git rm –cachedfile #停止跟踪文件但不删除$ git commit -m “commit messages” #提交所有更新过的文件$ git commit –amend #修改最后一次改动 $ git reset HEAD filename # 放弃提交到缓存区的指定文件$ git reset . # 放弃所有添加到缓存区的文件 $ git log #查看提交历史$ git log -p file #查看指定文件的提交历史$ git blame file #以列表方式查看指定文件的提交历史 $ git reset –hard HEAD #撤销工作目录中所有未提交文件的修改内容$ git checkout HEAD file #撤销指定的未提交文件的修改内容$ git revert commit #撤销指定的提交$ git log –before=”1 days” #退回到之前1天的版本 $ git branch #显示所有本地分支.$ git checkout -b branchname origin/branchname #创建远程分支到本地 并切换到该分支$ git checkout branch/tag #切换到指定分支和标签$ git branch new-branch #创建新分支$ git branch -d branch #删除本地分支$ git tag #列出所有本地标签$ git tag tagname #基于最新提交创建标签$ git tag -d tagname #删除标签 $ git merge branch #合并指定分支到当前分支$ git rebase branch #衍合指定分支到当前分支 $ git remote -v #查看远程版本库信息$ git remote show remote #查看指定远程版本库信息$ git remote add remote url #添加远程版本库$ git fetch remote #从远程库获取代码$ git pull remote branch #下载代码及快速合并$ git push remote branch #上传代码及快速合并$ git push remote :branch/tag-name #删除远程分支或标签$ git push –tags #上传所有标签 git 小乌龟 下载地址 Windows git可视化工具 放弃本地修改代码 未使用 git add 缓存代码时。 可以使用 git checkout – filepathname (比如： git checkout – readme.md ，不要忘记中间的 “–” ，不写就成了检出分支了！！)。放弃所有的文件修改可以使用 git checkout . 命令。 已经使用了 git add 缓存了代码。 可以使用 git reset HEAD filepathname （比如： git reset HEAD readme.md）来放弃指定文件的缓存，放弃所以的缓存可以使用 git reset HEAD . 命令。 已经用 git commit 提交了代码。 可以使用 git reset –hard HEAD^ 来回退到上一次commit的状态。此命令可以用来回退到任意版本：git reset –hard commitid 右键单击链接另存为可以下载地址]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 遇到的问题]]></title>
    <url>%2F2018%2F09%2F07%2Freact-problem%2F</url>
    <content type="text"><![CDATA[使用 React 中遇到的一些问题 dva 编译样式文件会生成后缀 class 无法正确匹配demo.less1234.demo&#123; color: red; font-size: 1.6rem;&#125; 1234.demo_sanc&#123; color: red; font-size: 1.6rem;&#125; 本意是为各个组件之间形成独立的样式，避免命名冲突 但是对于需要重复使用的组件 dom 结构因为 class 无法匹配导致样式缺失 123456:global&#123; .demo&#123; color: red; font-size: 1.6rem; &#125;&#125; 将样式添加到全局，编译不会添加后缀 Object.assignassign 是 ES6 提出的新特性，可以合并 JavaScript 对象注意: assign 是浅克隆 使用 Router 或者 state 时注意需要新建个对象地址 以免无法触发组件更新 componentDidUpdate 钩子函数 create-react-app打包地址默认为绝对路径(即服务器根目录)使用相对路径可以在 package.json 添加 homepage 为 . 打包之后的文件请求路径为相对路径 123456789101112131415161718192021222324&#123; &quot;name&quot;: &quot;react-demo&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;homepage&quot;: &quot;.&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: &#123; &quot;bootstrap&quot;: &quot;^4.1.3&quot;, &quot;react&quot;: &quot;^16.4.2&quot;, &quot;react-dom&quot;: &quot;^16.4.2&quot;, &quot;react-redux&quot;: &quot;^5.0.7&quot;, &quot;react-router-dom&quot;: &quot;^4.3.1&quot;, &quot;react-scripts&quot;: &quot;1.1.4&quot;, &quot;reactstrap&quot;: &quot;^6.4.0&quot;, &quot;redux&quot;: &quot;^4.0.0&quot;, &quot;redux-logger&quot;: &quot;^3.0.6&quot;, &quot;redux-thunk&quot;: &quot;^2.3.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;&#125; BroswerRouter 使用二级目录无法访问需要在 BrowserRouter 中设置 basename 和二级目录名称一致可以完成访问 1234567&lt;BrowserRouter basename=&apos;/Demo&apos; &gt; &lt;!-- 注意这里的 basename 和部署项目的二级目录一致 该项目部署地址在服务器根目录 Demo 文件夹下 --&gt; &lt;div&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;/&gt; &lt;Route path=&quot;/index&quot; component=&#123;Index&#125;/&gt; &lt;/div&gt;&lt;/BrowserRouter&gt; 详细 demo 看这里]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 入门]]></title>
    <url>%2F2018%2F08%2F16%2Fwebpack%2F</url>
    <content type="text"><![CDATA[webpack 入门读物 初次接触 webpack 安装依赖初始化项目1$ npm init -yes 生成 package.json 文件注意：文件目录为 webpack 会无法安装 webpack 依赖，需要修改 package.json 文件中 name 字段 全局以及文件夹内部安装 webpackwebpack 4.X 以后构建工具单独 需要单独安装 webpack-cli12$ npm install webpack webpack-cli -g$ npm install webpack webpack-cli -save-dev 注意：json 文件不支持注释，在使用时删除注释内容123456789101112131415161718&#123; &quot;name&quot;: &quot;webpack-demo&quot;, # 默认生成的是当前文件夹目录名称 为避免webpack安装冲突修改为 webpack-demo &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: &#123; &quot;webpack-cli&quot;: &quot;^3.1.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.16.5&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 使用创建需要打包的测试文件结构如下 app main.js module.js module.js123456// moudle.jsmodule.exports = function () &#123; let div = document.createElement(&apos;div&apos;); div.textContent = &quot;Hi there and greetings!&quot;; return div;&#125;; main.js123import Div from &apos;./module&apos;;document.getElementById(&apos;app&apos;).appendChild(Div()); 创建 webpack 配置文件 webpack.config.js12345678910module.exports = &#123; entry: __dirname + &apos;/app/main.js&apos;, 入口文件 output: &#123; path: __dirname + &apos;/dist&apos;, //打包后的文件存放的目录 filename: &apos;bundle.js&apos; //打包后输出文件的文件名 &#125;, module: &#123; rules: [] &#125;&#125; 执行命令1$ webpack --config webpack.config.js --mode development 可以看到 dist 目录下生成 bundle.js 为了避免每次打包需要使用上述大串命令可以在 package.json 中设置命令scripts 字段添加字段1&quot;start&quot;: &quot;webpack --config webpack.config.js --mode development&quot; 这里设置完成的 package.json123456789101112131415161718192021&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: &#123; &quot;css-loader&quot;: &quot;^1.0.0&quot;, &quot;style-loader&quot;: &quot;^0.22.1&quot;, &quot;webpack-cli&quot;: &quot;^3.1.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.16.5&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack --config webpack.config.js --mode development&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 之后可以使用1$ npm run start 执行打包过程 监听可以在 webpack 命令中添加 --watch 字段实现打包文件监听效果 1&quot;start&quot;: &quot;webpack --config webpack.config.js --mode development --watch&quot; 打包文件修改实时刷新 打包html插件 app 文件夹下新建 html 提供 title、meta 等信息，插件会按照这个文件作为模板生成新的 html 文件到指定文件夹1$ npm install html-webpack-plugin --save 1234567const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);plugins: [ new HtmlWebpackPlugin(&#123; // html引用自动插入 filename: &apos;index.html&apos;, template: &apos;app/index.html&apos; &#125;),] 配置后的 webpack.config.js123456789101112131415161718const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: __dirname + &apos;/app/main.js&apos;, //入口文件 output: &#123; path: __dirname + &apos;/dist&apos;, //打包后的文件存放的目录 filename: &apos;bundle.js&apos; // 打包后输出文件的文件名 &#125;, module: &#123; rules: [] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;app/index.html&apos; &#125;) ]&#125; dist 下生成的 html 文件中自动调整引用的 js 文件名称 打包cssapp 文件夹下新建文件 main.css123456#app &#123; border: 1px solid #eee; background: #333; color: #ddd; padding: .5rem 1rem;&#125; main.js 文件内引入 main.css 样式表1import &apos;./main.css&apos;; 打包会报错123ERROR in ./app/main.css 1:0Module parse failed: Unexpected character &apos;#&apos; (1:0)You may need an appropriate loader to handle this file type. 可以通过 style-loader 和 css-loader 实现 css 文件的打包安装依赖1$ npm install style-loader css-loader --save webpack.config.js 文件设置 css 打包规则123456rules: [ &#123; test: /\.css$/, // 正则匹配所有css文件 loader: [&apos;style-loader&apos;,&apos;css-loader&apos;] &#125;] 再次执行打包命令 可以看打包文件中引入了 css 样式表 css文件单独打包如果想将 css 文件单独打包出来可以使用插件 mini-css-extract-plugin注意：webpack 4 只能使用这个了，之前的插件 extract-text-webpack-plugin不好使了1234567891011121314151617181920212223const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123;&#125; &#125;,&#123; loader: &apos;css-loader&apos;, options: &#123;&#125; &#125; ] &#125; ]&#125;plugins: [ new MiniCssExtractPlugin(&#123; // css单独分离 filename: &quot;[name].css&quot; &#125;),] 配置完成的 webpack.config.js123456789101112131415161718192021222324252627282930313233343536const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);module.exports = &#123; entry: __dirname + &apos;/app/main.js&apos;, //入口文件 output: &#123; path: __dirname + &apos;/dist&apos;, //打包后的文件存放的目录 filename: &apos;bundle.js&apos; //打包后输出文件的文件名 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123;&#125; &#125;,&#123; loader: &apos;css-loader&apos;, options: &#123;&#125; &#125; ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // html引用自动插入 filename: &apos;index.html&apos;, template: &apos;app/index.html&apos; &#125;), new MiniCssExtractPlugin(&#123; // css单独分离 filename: &quot;[name].css&quot;, &#125;), ]&#125; 运行打包命令 npm run start 可以看到在 dist 文件夹下生成的 main.css 压缩 css 代码 插件 optimize-css-assets-webpack-plugin 用来压缩 css 代码文档123456789new OptimizeCssAssetsPlugin(&#123; cssProcessorOptions: &#123; mergeLonghand: false, discardComments: &#123; removeAll: true &#125; &#125;, canPrint: true,&#125;), sass 编译安装 sass-loader 和 node-sass1234567891011121314&#123; test: /\.scss$/, use: [ &#123; loader: &apos;style-loader&apos; &#125;, &#123; loader: MiniCssExtractPlugin.loader // css 代码单独分离 &#125;, &#123; loader: &apos;css-loader&apos; &#125;, &#123; loader: &apos;sass-loader&apos; &#125; ]&#125; 需要代码的话可以看这里的 demo]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[占位图片]]></title>
    <url>%2F2018%2F08%2F15%2Fimg%2F</url>
    <content type="text"><![CDATA[占位图片 https://placeholdit.imgix.net/~text?txtsize=30&amp;txt=1920x680&amp;w=1920&amp;h=680 txtsize: 字体大小txt: 文字内容w: 宽h: 高 这个网址可以生产站位图片调整大小图片文字等]]></content>
      <tags>
        <tag>img</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp 入门]]></title>
    <url>%2F2018%2F08%2F09%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp 入门gulp 使用 nodejs 实现前端代码自动化的工具，与此类似的库也存在很多，目前主流库为 gulp 以及 webpack 这篇文章对于 gulp 做个简单的入门介绍 gulp 是一种自动化构建工具 安装依赖1$ npm install gulp --save 基本使用gulp 主要通过 task 来实现任务流程, 可以使用 pipe 传递每个步骤处理完成后的结果 在根目录新建文件夹 csscss 文件夹下新建文件 test.css这里的根目录是指 gulpfile.js 所在目录 测试12345html,body &#123; width: 100%; height: 100%; margin: 0;&#125; 在根目录创建 gulpfile.js 文件, gulp 执行的文件 123456var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function () &#123; gulp.src(&apos;css/test.css&apos;) .pipe(gulp.dest(&apos;dist&apos;))&#125;) 多个任务流, 可以限制执行顺序12345678var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, [&apos;css&apos;])gulp.task(&apos;css&apos;,function()&#123; gulp.src(&apos;css/test.css&apos;) .pipe(gulp.dest(&apos;dist&apos;))&#125;) task 方法可以通过添加参数实现顺序控制 default 执行之前先执行任务 css 将 css 目录下的 test.css 文件重新生成到 dist 目录下 这里 gulp.src 需要处理的文件gulp.dest 输出处理完成的文件 在根目录打开 cmd 或者 git bash 执行命令1$ gulp gulp 会执行默认任务流 default 可以添加参数确保 gulp 执行指定的任务 1$ gulp sass_css 执行指定的任务 sass_css 注意： gulp 命令如果报错 No such file or directory需要全局安装 gulp1$ npm install gulp -g 执行完成后会在根目录多出文件夹 dist 生成新的 test.css 文件 了解基本用法后, 提供几个常见插件的使用 注意： 我这里只是提到常用的几个插件 更多更详细的 看这里 css 插件几个常见的 css 相关插件 sass 编译为 css要实现 sass 的编译使用相关的插件 sass 编译插件 插件名称: gulp-sass 首先需要 安装 gulp-sass 插件1npm install gulp-sass --save 在 css 文件夹下新建文件 main.scss1234$width: 100px;.container&#123; width: $width;&#125; 编译 gulpfile.js 文件12345678var sass = require(&apos;gulp-sass&apos;);// 新建一个任务流 任务流名称可以随意命名gulp.task(&apos;sass_css&apos;, function () &#123; gulp.src(&apos;css/main.scss&apos;) // scss 路径 .pipe(sass()) // 编译 scss .pipe(gulp.dest(&apos;dist&apos;)) // 输出到 dist 文件夹下&#125;) 根目录打开 cmd 或者 git bash 执行命令1$ gulp sass_css 执行 gulp 的任务 sass_css会在根目录下生产 dist 文件夹, 以及编译好的 main.css css 文件压缩css 压缩插件 插件名称: gulp-minify-css 安装插件1$ npm install gulp-minify-css --save 修改 gulpfile.js 文件12345678var minifyCss = require(&apos;gulp-minify-css&apos;);// 编译 sass_cssgulp.task(&apos;sass_css_min&apos;, function () &#123; gulp.src(&apos;css/main.scss&apos;) // scss 路径 .pipe(sass()) // 编译 scss .pipe(minifyCss()) // 压缩 css 文件 .pipe(gulp.dest(&apos;dist&apos;)) // 输出到 dist 文件夹下&#125;) 根目录打开 cmd 或者 git bash 执行命令1$ gulp sass_css_min 这里的压缩会删除不必须的空格以及换行 打开dist内的 main.css 生成的文件内容是一行 css 样式 文件合并文件合并 插件名称: gulp-concat 安装插件1$ npm install gulp-concat --save 在 css 目录下再新建文件 demo.scss12345.demo&#123; width: 100px; height: 100px; background: #2ac3ff;&#125; 修改 gulpfile.js 文件12345678// 编译 sass_css_mingulp.task(&apos;sass_css_concat_min&apos;, function () &#123; gulp.src(&apos;css/*.scss&apos;) // scss 路径 *.scss 适配所有以 scss 结尾的文件 .pipe(sass()) // 编译 scss .pipe(concat(&apos;dist/main.css&apos;)) // concat 需要给合并文件的路劲以及名称 .pipe(minifyCss()) // 压缩 css 文件 .pipe(gulp.dest(&apos;&apos;)) // 输出文件 这里的路劲不需要写 流将 dist/main.css 合并后的文件进行压缩然后输出&#125;) 根目录打开 cmd 或者 git bash 执行命令1$ gulp sass_css_concat_min 根目录下生成 dist/main.css 会将 main.scss 和 demo.scss 文件内容合并压缩 重命名文件重命名 插件名称: gulp-rename 压缩文件重新命名 添加后缀 .min 安装插件1$ npm install gulp-rename --save 修改 gulpfile.js 文件12345678910var rename = require(&apos;gulp-rename&apos;);// 编译 sass_css_concat_min gulp.task(&apos;sass_css_concat_min_rename&apos;, function () &#123; gulp.src(&apos;css/*.scss&apos;) // scss 路径 *.scss 适配所有以 scss 结尾的文件 .pipe(sass()) // 编译 scss .pipe(concat(&apos;dist/main.css&apos;)) // concat 需要给合并文件的路劲以及名称 .pipe(minifyCss()) // 压缩 css 文件 .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) // 修改压缩文件名称 添加后缀 .min .pipe(gulp.dest(&apos;&apos;)) // 输出文件 这里的路劲不需要写 流将 dist/main.css 合并后的文件进行压缩然后输出&#125;) 根目录打开 cmd 或者 git bash 执行命令1$ gulp sass_css_concat_min_rename 根目录下生成 dist/main.min.css 会将 main.scss 和 demo.scss 文件内容合并压缩 rename 也可以将文件命名为任意名称文档 js 插件压缩插件压缩 js 文件 插件名称: gulp-uglify 用法12345gulp.task(&apos;js_min_ugly&apos;,function () &#123; gulp.src(&apos;js/*/*.js&apos;) // 读取文件 .pipe(uglify()) // 压缩 .pipe(gulp.dest(&apos;dist&apos;)) // 输出&#125;) 注意： 文件压缩插件不支持 es6 需要使用 babel 编译 所以如果使用 es6 语法, 首先需要使用 babel 进行编译 编译插件编译 js 文件为可以被浏览器直接运行的文件 插件名称: gulp-babel123456gulp.task(&apos;js_min_ugly&apos;,function () &#123; gulp.src(&apos;js/*/*.js&apos;) // 读取文件 .pipe(babel(&#123;presets: [&apos;es2015&apos;]&#125;)) // 编译 .pipe(uglify()) // 压缩 压缩不支持 es6 语法,需要使用 babel 编译 .pipe(gulp.dest(&apos;dist&apos;)) // 输出&#125;)]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线图片转 ico]]></title>
    <url>%2F2018%2F08%2F07%2Ficon%2F</url>
    <content type="text"><![CDATA[在线图片转换 ico 地址(https://lvwenhan.com/convertico/) 在线转换器 需要背景透明的小伙伴可以尝试下 IconWorkshop 这个软件只有30天试用期 下载地址 这个倒是十分好用的地址]]></content>
      <tags>
        <tag>ico</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github 绑定独立域名]]></title>
    <url>%2F2018%2F08%2F07%2Fdomain%2F</url>
    <content type="text"><![CDATA[github 绑定独立域名 购买域名, 添加解析我的域名从阿里云购买的，以阿里云为例说明流程 在阿里云域名服务购买自己喜欢的域名链接 在阿里云控制台云解析 DNS 添加记录 解析自己的博客地址 三个位置依次选中 CNAME www 博客地址 重复操作添加 CNAME @ 博客地址 使用 github 博客页面可以参考 链接 非阿里云购买的域名解析 控制台域名管理 添加自己购买的域名 在自己购买域名的平台修改 DNS dns12.hichina.com dns11.hichina.com 控制台云解析 DNS 步骤同上 添加 github 重定向在博客根目录下添加文件 CNAME，文件内写入域名注意： 文件没有后缀名 写入内容仅域名地址 例如：kenghuo.ink 或者在 github 仓库 setting 中 Github Page 添加设置 Custom domain 添加域名]]></content>
      <tags>
        <tag>blog</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Worker]]></title>
    <url>%2F2018%2F08%2F03%2Fworker%2F</url>
    <content type="text"><![CDATA[web worker 的使用 JS 为单线程, 一些计算量较大的代码肯定会影响整体程序的执行速度,而且, 多核计算机的性能也无法高效利用,为了解决这些问题, HTML5 提出 Web Worker , 可以使 JS 一些可以同时进行的事件放在独立的小线程中执行 使用限制在 worker 子线程中，可以获得下列对象 navigator对象 location对象，只读 这里不能进行 location 赋值实现页面跳转！！！ XMLHttpRequest对象 ajax 请求 setTimeout/setInterval方法 Application Cache 通过importScripts()方法加载其他脚本 创建新的Web Worker worker线程不能获得下列对象 DOM对象 window对象 document对象 parent对象 使用主线程使用 new 新建一个子线程, 参数为线程文件Worker1var worker = new Worker(&apos;work.js&apos;); 调用 postMessage 方法向子线程传递消息通过 onmessage 监听子线程发送的消息 onerror 监听错误信息 123456789101112worker.postMessage(&#123;name:&apos;Kenghuo&apos;, title: &apos;Hello&apos;&#125;);worker.onmessage = function(event)&#123; console.log(event); document.getElementById(&apos;title&apos;).innerHTML = event.data;&#125;worker.onerror = function(error)&#123; console.log(error);&#125; 子线程 新建的 work.js 文件 通过 onmessage 来接收主线程发送的消息通过 postMessage 发送处理完成后的信息通过 importScript 引入别的 JS 文件 1234567importScript(&apos;func.js&apos;);onmessage = (event) =&gt; &#123; console.log(event); postMessage(add(event.data.title + &apos; &apos; + event.data.name));&#125; demo]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>worker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键分享]]></title>
    <url>%2F2018%2F08%2F02%2Fshare%2F</url>
    <content type="text"><![CDATA[一键分享 一键分享的代码 复制这段代码到希望分享的网页, 即可实现一键分享功能1234567891011121314151617181920212223242526window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdSnsKey&quot;: &#123;&#125;, &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;1&quot;, &quot;bdMiniList&quot;: [&quot;tsina&quot;, &quot;weixin&quot;, &quot;mail&quot;, &quot;linkedin&quot;, &quot;copy&quot;, &quot;print&quot;], &quot;bdPic&quot;: &quot;&quot;, &quot;bdStyle&quot;: &quot;0&quot;, &quot;bdSize&quot;: &quot;32&quot; &#125;, &quot;slide&quot;: &#123; &quot;type&quot;: &quot;slide&quot;, &quot;bdImg&quot;: &quot;3&quot;, &quot;bdPos&quot;: &quot;left&quot;, &quot;bdTop&quot;: &quot;100&quot; &#125;&#125;;with(document) 0[ (getElementsByTagName(&apos;head&apos;)[0] || body) .appendChild(createElement(&apos;script&apos;)) .src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5)];// 这里不支持 with 关键字的代码/* document.getElementsByTagName(&apos;head&apos;)[0].appendChild(document.createElement(&apos;script&apos;)).src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5) */ 注意： JavaScript 严格模式不支持 with 关键字, 需要修改代码 官方百度分享]]></content>
      <tags>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 和 github 创建博客最简单粗暴的方法]]></title>
    <url>%2F2018%2F07%2F26%2Fhexo-init%2F</url>
    <content type="text"><![CDATA[在 github 上 使用 hexo 创建博客最简单粗暴的方法 最简单粗暴创建博客的方法 注册账户 注册 github 账号注册地址 新建个人仓库 打开 github page详情见搭建博客 注册账号之后，需要添加SSH Key使用 git 管理代码需要这东西 安装程序 安装 nodejs 下载地址没有特殊要求直接安装一直下一步就行 安装 hexo 在安装 nodeJS 之后，可以使用 npm 包管理器 安装 hexo 1$ npm install hexo hexo-cli -g # 全局安装 hexo 安装 git 下载地址根据需要安装对应版本的 git安装成功之后，右键单击出现 Git Bash Here 以及 Git GUI 说明成功 使用 hexo找个空文件夹直接1$ hexo init 在 hexo init 完成后记得安装包 hexo-deployer-git包1$ npm install hexo-deployer-git --save 修改配置文件 _config.yml123456url: https://github.com/github用户名 # 提交的账户名deploy: type: git repo: https://github.com/github用户名/github用户名.github.io # 提交的仓库 branch: master 配置完成后，依次键入以下命令提交123$ hexo clean # 清理原有的文件 public 文件夹$ hexo generate # 重新打包生成 public 文件夹$ hexo deploy # 提交文件到指定 github 仓库 在本地预览当前博客效果本地123$ hexo clean # 清理原有的文件 public 文件夹$ hexo generate # 重新打包生成 public 文件夹$ hexo server # 开启本地服务器 4000 端口号 浏览器 localhost:4000 可以看到当前博客生成内容]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 常见麻烦]]></title>
    <url>%2F2018%2F07%2F26%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo 使用过程中遇到的麻烦 没反应命令行键入 hexo d 毫无反应 原因: 缺少包 hexo-deployer-git hexo 从版本 2.x.x 升级到 3.x.x 删除了内置的 git 包需要单独安装 hexo-deployer-git 包 原因: 配置文件 url 以及 deploy 未配置123456url: https://github.com/username # 这里是提交的账户deploy: type: git repo: https://github.com/username/username.github.io # 这里是提交仓库的地址 branch: master hexo d 报错可能是 Git 抽风 可以删除根目录下的 .deploy_git 文件夹重新执行 hexo d]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2F2018%2F07%2F26%2Fgit%2F</url>
    <content type="text"><![CDATA[git 常用命令这里总结一些日常工作中使用git管理代码的常用命令对这些命令不感冒的Windows小伙伴也可以使用 git 可视化工具小乌龟下载地址 clone克隆或者叫下载, 将远程服务器上的仓库文件下载到本地 12git clone git@gitee.com:xxx `&lt;dirName&gt;` git clone https://gitee.com/xxx `&lt;dirName&gt;` 将仓库 git@gitee.com:xxx 中的文件下载到本地 ./dirName 目录下将仓库 https://gitee.com/xxx 中的文件下载到本地 ./dirName 目录下 两个命令的区别在于 使用 SSH 下载的内容提交不需要登录名以及密码注意：不论哪个 git 命令提交代码都需要 SSH公匙 验证 SSH Key查看公钥 12$ cd ~/.ssh # 进入指定文件夹 $ ls # 查看文件夹下的文件 存在这两个文件文件1id_rsa id_rsa.pub 文件 id_rsa.pub 储存当前生成的随机数公钥 否则生成公钥1234$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot;$ ssh-keygen -t rsa -C &quot;youremail&quot;连续3个回车 在 github 设置生成的公钥执行命令1ssh git@github.com 出现文字123PTY allocation request failed on channel 0Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 设置公钥成功 push将修改内容交于 git 控制12$ git add . # 提交全部修改的文件$ git add xxx # 提交指定文件 将提交的修改添加到缓冲区1$ git commit -m &apos;xxx&apos; # xxx 提交的注释性内容 上传提交的修改1$ git push origin &lt;branchName&gt; # 提交指定分支的修改 branch 添加分支 git branch &lt;newBranchName&gt; 添加新分支 newBranchName新分支的改动不会影响原有分支的文件 注意切换分支之前对当前分支进行提交 (commit) 操作推送之前注意对应分支, 除了默认分支不需要以外, 其余分支提交 git push origin &lt;branchName&gt; 切换分支 git checkout &lt;branchName&gt; 切换到分支 branchName多个分支之间的文件不受彼此影响 合并分支修改 git merge &lt;branchName&gt; 将当前分支与 branchName 分支合并 resetgit 放弃当前的修改内容 未使用 git add 缓存代码可以使用 git checkout -- filepathname 放弃当前修改注意 该命令中 -- 必不可少用于确保放弃当前修改回退为上次提交内容 已经使用 git add 添加代码到本地缓存可以使用 git reset HEAD filepathname 将指定文件会蹲到上一次提交 已经使用 git commit 提交代码可以使用 git reset --hard HEAD 回退到上次提交内容 其他命令可以参考这里;]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F07%2F24%2Fsort%2F</url>
    <content type="text"><![CDATA[几种排序算法 冒泡排序冒泡排序一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 123456789101112131415function bubbleSort(arr) &#123; let len = arr.length; console.time(&apos;原始冒泡排序时间&apos;); for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 let temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; console.timeEnd(&apos;原始冒泡排序时间&apos;); return arr;&#125; 优化标记已经完成的排序序号, 从未排序的位置开始进行排序, 减少内层循环次数 123456789101112131415161718function bubbleSort2(arr) &#123; let i = arr.length-1; //初始时,最后位置保持不变 console.time(&apos;优化冒泡排序时间&apos;); while ( i&gt; 0) &#123; let pos= 0; // 每趟开始时,无记录交换 for (let j = 0; j&lt; i; j++)&#123; if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 let tmp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; i = pos; // 为下一趟排序作准备 &#125; console.timeEnd(&apos;优化冒泡排序时间&apos;); return arr;&#125; 升级版冒泡排序从前向后同时进行排序操作, 记录排序序号 12345678910111213141516171819202122function bubbleSort3(arr3) &#123; var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time(&apos;2.改进后冒泡排序耗时&apos;); while (low &lt; high) &#123; for (j= low; j&lt; high; ++j) &#123; //正向冒泡,找到最大者 if (arr[j]&gt; arr[j+1]) &#123; tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; &#125; --high; //修改high值, 前移一位 for (j=high; j&gt;low; --j) &#123; //反向冒泡,找到最小者 if (arr[j]&lt;arr[j-1]) &#123; tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; &#125; &#125; ++low; //修改low值,后移一位 &#125; console.timeEnd(&apos;2.改进后冒泡排序耗时&apos;); return arr3;&#125; 选择排序选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 123456789101112131415161718function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time(&apos;选择排序耗时&apos;); // 计时开始 for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd(&apos;选择排序耗时&apos;); // 计时结束 return arr;&#125; 插入排序插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 1234567891011121314function insertionSort(array) &#123; console.time(&apos;插入排序耗时：&apos;); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while ( array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; console.timeEnd(&apos;插入排序耗时：&apos;); return array;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2F07%2F20%2Fblog%2F</url>
    <content type="text"><![CDATA[搭建个人博客的方法 注册github账号注册地址 创建个人仓库登录账户之后 &gt; new repository(注意再次之前需要登录邮箱验证账户) &gt; 进入 Settings 找到 GitHub Pages &gt; choose a theme &gt; 之后再次进入 Settings 在 GitHub Pages 位置多出来 Your site is published at https://kenghuo.github.io/ 表示博客创建成功 点击链接可以进入当前博客 如果想要使用类似 https://kenghuo.github.io/ 这样的域名作为博客地址, 需要仓库名称与账号名称一致 否则的话你的博客地址会变成这样 https://kenghuo.github.io/akang.github.io/ 克隆代码到本地进入已经创建好的个人仓库 有个绿色的按钮 clone and download 可以使用git 或者直接下载压缩包 Download ZIP git clone https://github.com/kenghuo/kenghuo.github.io.git dirname 或者 git clone git@github.com:kenghuo/kenghuo.github.io.git dirname 都可以 dirname 为下载完成的文件夹名称 可以自定义 点击 Download ZIP 下载压缩包 解压缩也可以得到完整的项目 编译博客页面也可以通过HTML可以自定义页面 入口文件名称为 index.html 也可以通过 hexo 搭建页面hexo Github]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 基本语法]]></title>
    <url>%2F2018%2F07%2F20%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown 语法 Markdown 是一种轻量级标记语言，这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML（或是 HTML）” 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。 英文参考文献(https://github.com/DavidAnson/markdownlint/blob/v0.10.0/doc/Rules.md)英文参考文献(https://daringfireball.net/projects/markdown/syntax) 中文参考文献(http://www.markdown.cn/)中文参考文献(https://github.com/younghz/Markdown) Markdown 完全支持 HTML 语法Markdown 完全支持 HTML 语法Markdown 完全支持 HTML 语法 标题同 html h1 ~ h6 文字前加 # 个数表示标题大小, 越少越大(注意一级标题下存在下划线)此外, 一行文本之后添加 = 或者 - 也可以作为一级或者二级标题出现 符号数量任意 123456# 一级标题## 二级标题...###### 六级标题 123456一级标题===二级标题--- 列表有序列表数字加上 .(英文句号) 加个空格 即可构成有序列表数字可以随意写, markdown语法会自动调整为顺序编码 123451. 水果 1. 苹果 1. 香蕉1. 蔬菜1. 小麦 水果 苹果 香蕉 蔬菜 小麦 无序列表* - + . 加个空格 即可构成无序列表同级列表项前的符号保持一致下级子列表 仅需要缩进一格1234567- 测试1 + 测试1.1 * 测试1.1.1 + 测试1.2 + 测试1.3- 测试2- 测试3 测试1 测试1.1 测试1.1.1 测试1.2 测试1.3 测试2 测试3 插入url[ ] ( ) 两个符号构成 [ ] 描述性文字 ( ) 链接地址[ ] 放的是 a 标签里的文字信息 ( ) 路径地址同 html的 a 标签 1234567&lt;a href=&quot;https://www.baidu.com/&quot; title=&quot;类似 html 的title&quot; &gt;百度&lt;/a&gt; [百度](https://www.baidu.com/) 行内式[百度][baidu][baidu]:https://www.baidu.com/ &quot;类似 html 的title&quot; 参考式 可以放在任意位置 比如文本末尾处 效果 百度 百度 百度 插入图片! [ ] ( ) 这三个部分构成图片样式 !是加载图片的标志性符号[ ] 注释性文字 ( ) 图片路径 可以使用相对路径 也可以使用绝对路径 同 html 的 img 标签 12345&lt;img src=&quot;/img/&quot; alt=&quot;百度&quot; /&gt;![狗子](/img/avatar.png)![不存在的图片](#) 效果 粗体、斜体、删除线粗体：在文字前后添加 * 或者 __ (注意符号与文字间不要有空格, 开始标记和结尾标记一致)斜体：在文字前后添加 或者 _删除线：在文字前后添加 ~~ 12345678测试 正常文字样式测试 __粗体文字样式__测试 _斜体文字样式_测试 ~~删除线文字样式~~ 测试 正常文字样式 测试 粗体文字样式 测试 斜体文字样式 测试 删除线文字样式 引用在文字前面加上 &gt;引用支持嵌套 12345&gt; To do or not to do, this is a problem -- Shakespeare&gt; 这里是一级引用 &gt; &gt; 可以在后边嵌套.&gt; &gt; &gt; 甚至可以是多个嵌套等级. To do or not to do, this is a problem – Shakespeare 这里是一级引用 可以在后边嵌套. 甚至可以是多个嵌套等级. 表格两个 | 之间是一个单元格表头与表格主体之间通过 - (任意数量英文减号) 分割分割线单元格数量不少于行内单元格, 比如每行有三个单元格, 分割线大于等于三个行与行之间不要有空行 1234| 姓名 | 地址 | 标题 ||-|-|-|| 阿康 | kenghuo.github.io | markdown || 每行 | 单元格数量一样 | 不然就不是表格了 | 姓名 地址 标题 阿康 kenghuo.github.io markdown 每行 单元格数量一样 不然就不是表格了 代码块12345前后添加 __```__ 注意前边符号写完后需要换行因此可以不换行加上注释性内容, 而不会出现在代码块中 效果如下123for (let i = 0; i &lt; 10; i++)&#123; console.log(&quot;hello markdown!&quot;);&#125; 换行同一段落内换行, 可以在 需要换行的地方 两个空格 回车 段落换行, 需要文字之间出现空行 123456段落内部换行 (两个空格)换行段落1段落2 效果 段落内部换行换行 段落1 段落2]]></content>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
